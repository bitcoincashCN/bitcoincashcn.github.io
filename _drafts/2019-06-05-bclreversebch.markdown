---
layout: post
title:  "BCH分叉的各种问题搜集"
date:   2019-06-05
categories: 教程和实验
tags: BCH Clashic BCH原链 操作教程 技术原理 分叉
---

* content
{:toc}



# 四、延伸讨论

## 1、BCH和BSV为什么在分叉后没有互相覆盖？

ABC链在556767块率先打出的块中包含了DSV（OP_CHECKDATASIGVERIFY）和CTOR（规范排序）特性，那么SV链认为该区块无效，是不可能承认ABC 556767块，以及所有的后继块的。

反之，SV链在556767块打出的块包含了OP_MUL，是一个ABC不支持的操作码，那么ABC同样认为该区块无效，是不可能承认SV 556767块，以及所有的后继块的。

又如，如果SV打出一个大于32MB的区块，或者在一个脚本中加入超过201个操作码等类似操作，都能造成事实上的不兼容。

因此，任何一方只要打出对方不支持的块，那么这两条链在事实上就分道扬镳了，无论算力多还是算力少，无论区块高度领先还是落后。

这是双向的互相不兼容，而BCH原链和新链是单向的不兼容。

## 2、原链分叉的危险性

技术原理讲述起来很复杂，目前我们看到的情况是凡是硬分叉均可能会引起原链分叉，凡是软分叉都不会引起原链分叉。

## 3、谁才是真正的BCH？

当然是BCH原链了。（这句话看起来很不严肃）

## 4、BCH原链的chainwork有可能超越新链？

这种可能性是存在的：

* 算力的成本随硬件成本下降而下降（比如摩尔定律）。
* BCH原链的算力一旦超过BCH新链，则chainwork反超立即进入倒计时。
* 去中心化的存活能力、抗风险、容错能力更强。
* 利益驱动。

但具体什么时候，无法逆料。放在一个很长的历史眼光去看待这件事情，在逻辑上讲A可以覆盖B，而B无法覆盖A，永远不会被覆盖的BCH原链PK有可能被覆盖掉BCH新链，最终的胜利无疑只能属于BCH原链。

## 5、BCH新链应该采取什么动作阻止被原链覆盖？

有两种办法：

* 修改forkid
* 代码中设置检查点

